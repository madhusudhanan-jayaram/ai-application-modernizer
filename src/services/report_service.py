"""
Report Service - Handles report generation, formatting, and export.
Supports Markdown, HTML, PDF, and ZIP archive generation.
Manages report caching and metadata.
"""

import json
import zipfile
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from src.utils.logger import setup_logger

logger = setup_logger(__name__)


class ReportError(Exception):
    """Base exception for report errors."""

    pass


class ReportService:
    """
    Service for generating and exporting analysis/migration reports.

    Capabilities:
    - Format reports as Markdown
    - Convert to HTML with styling
    - Generate PDF reports (via markdown2pdf)
    - Create ZIP archives with all artifacts
    - Manage report metadata and caching
    - Generate index and table of contents
    """

    # HTML template for report
    HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
        }}
        .header h1 {{
            margin: 0;
            font-size: 2.5em;
        }}
        .metadata {{
            font-size: 0.9em;
            opacity: 0.9;
            margin-top: 10px;
        }}
        .toc {{
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }}
        .toc h2 {{
            margin-top: 0;
        }}
        .toc ul {{
            list-style: none;
            padding: 0;
        }}
        .toc li {{
            padding: 8px 0;
        }}
        .toc a {{
            color: #667eea;
            text-decoration: none;
        }}
        .toc a:hover {{
            text-decoration: underline;
        }}
        .content {{
            background: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
        }}
        .section {{
            margin-bottom: 40px;
        }}
        .section h2 {{
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }}
        .section h3 {{
            color: #764ba2;
            margin-top: 20px;
        }}
        code {{
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }}
        pre {{
            background: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }}
        pre code {{
            background: none;
            padding: 0;
        }}
        .summary-box {{
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }}
        .warning {{
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }}
        th {{
            background-color: #667eea;
            color: white;
        }}
        tr:nth-child(even) {{
            background-color: #f9f9f9;
        }}
        .footer {{
            text-align: center;
            color: #999;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{title}</h1>
        <div class="metadata">
            <p>Repository: <strong>{repository}</strong></p>
            <p>Generated: {generated_at}</p>
        </div>
    </div>

    {toc}

    <div class="content">
        {content}
    </div>

    <div class="footer">
        <p>Report generated by AI Application Modernizer</p>
        <p>For questions or feedback, visit the project repository</p>
    </div>
</body>
</html>"""

    def __init__(self):
        """Initialize report service."""
        from config.settings import settings

        self.reports_dir = settings.REPORTS_DIR
        self.reports_dir.mkdir(parents=True, exist_ok=True)

        self.report_cache = {}

        logger.debug("Report service initialized")

    def generate_markdown_report(self, report_data: Dict[str, Any]) -> str:
        """
        Generate markdown report from data.

        Args:
            report_data: Report data dictionary

        Returns:
            Markdown report string
        """
        logger.debug("Generating markdown report")

        lines = []

        # Title
        lines.append(f"# {report_data.get('report_type', 'Report')}\n")

        # Metadata
        lines.append("---\n")
        lines.append(
            f"**Repository**: {report_data.get('repository_url', 'Unknown')}\n"
        )
        lines.append(
            f"**Generated**: {report_data.get('generated_at', datetime.now().isoformat())}\n"
        )
        lines.append("---\n\n")

        # Executive Summary
        summary = report_data.get("executive_summary", {})
        if summary:
            lines.append("## Executive Summary\n\n")
            lines.append(f"**Overview**: {summary.get('overview', '')}\n\n")
            lines.append(
                f"- **Current Stack**: {summary.get('current_stack', 'Unknown')}\n"
            )
            lines.append(f"- **Target Stack**: {summary.get('target_stack', 'Unknown')}\n")
            lines.append(f"- **Difficulty**: {summary.get('difficulty', 'Unknown')}\n")
            lines.append(f"- **Effort**: {summary.get('effort', 'Unknown')}\n")
            lines.append(f"- **Duration**: {summary.get('duration', 'Unknown')}\n\n")

            # Next Steps
            next_steps = summary.get("next_steps", [])
            if next_steps:
                lines.append("### Next Steps\n\n")
                for i, step in enumerate(next_steps, 1):
                    lines.append(f"{i}. {step}\n")
                lines.append("\n")

        # Sections
        sections = report_data.get("sections", [])
        for section in sections:
            lines.append(f"\n## {section.get('title', 'Section')}\n\n")
            lines.append(f"{section.get('content', '')}\n")

        return "".join(lines)

    def generate_html_report(self, report_data: Dict[str, Any]) -> str:
        """
        Generate HTML report from data.

        Args:
            report_data: Report data dictionary

        Returns:
            HTML report string
        """
        logger.debug("Generating HTML report")

        # Generate markdown first, then format for HTML
        markdown = self.generate_markdown_report(report_data)

        # Convert markdown to HTML (simple conversion)
        html_content = self._markdown_to_html(markdown)

        # Generate table of contents
        toc = self._generate_toc(report_data.get("sections", []))

        # Fill template
        summary = report_data.get("executive_summary", {})
        html = self.HTML_TEMPLATE.format(
            title=report_data.get("report_type", "Report"),
            repository=report_data.get("repository_url", "Unknown"),
            generated_at=report_data.get(
                "generated_at", datetime.now().isoformat()
            ),
            toc=toc,
            content=html_content,
        )

        return html

    def save_report(
        self,
        report_data: Dict[str, Any],
        format: str = "markdown",
        filename: Optional[str] = None,
    ) -> Path:
        """
        Save report to file.

        Args:
            report_data: Report data dictionary
            format: Format (markdown, html, json)
            filename: Optional custom filename

        Returns:
            Path to saved report

        Raises:
            ReportError: If save fails
        """
        try:
            if not filename:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                repo_name = (
                    report_data.get("repository_url", "report")
                    .split("/")[-1]
                    .replace(".git", "")
                )
                filename = f"modernization_{repo_name}_{timestamp}"

            # Generate content
            if format == "markdown":
                content = self.generate_markdown_report(report_data)
                extension = ".md"
            elif format == "html":
                content = self.generate_html_report(report_data)
                extension = ".html"
            elif format == "json":
                content = json.dumps(report_data, indent=2)
                extension = ".json"
            else:
                raise ReportError(f"Unsupported format: {format}")

            # Save file
            filepath = self.reports_dir / f"{filename}{extension}"
            filepath.write_text(content, encoding="utf-8")

            logger.info(f"Report saved: {filepath}")

            # Cache
            self.report_cache[str(filepath)] = {
                "data": report_data,
                "format": format,
                "created_at": datetime.now().isoformat(),
            }

            return filepath

        except Exception as e:
            logger.error(f"Failed to save report: {str(e)}")
            raise ReportError(f"Report save failed: {str(e)}") from e

    def create_report_archive(
        self,
        report_data: Dict[str, Any],
        code_files: List[str] = None,
        filename: Optional[str] = None,
    ) -> Path:
        """
        Create ZIP archive with all report files and code.

        Args:
            report_data: Report data dictionary
            code_files: List of generated code files to include
            filename: Optional archive filename

        Returns:
            Path to created archive

        Raises:
            ReportError: If archive creation fails
        """
        try:
            logger.debug("Creating report archive")

            if not filename:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                repo_name = (
                    report_data.get("repository_url", "report")
                    .split("/")[-1]
                    .replace(".git", "")
                )
                filename = f"modernization_{repo_name}_{timestamp}"

            # Create temporary directory structure
            archive_path = self.reports_dir / f"{filename}.zip"

            with zipfile.ZipFile(archive_path, "w", zipfile.ZIP_DEFLATED) as zf:
                # Add markdown report
                md_content = self.generate_markdown_report(report_data)
                zf.writestr("REPORT.md", md_content)

                # Add HTML report
                html_content = self.generate_html_report(report_data)
                zf.writestr("REPORT.html", html_content)

                # Add metadata
                metadata = {
                    "repository": report_data.get("repository_url"),
                    "generated_at": report_data.get("generated_at"),
                    "report_type": report_data.get("report_type"),
                    "sections": len(report_data.get("sections", [])),
                    "files_included": len(code_files or []),
                }
                zf.writestr("metadata.json", json.dumps(metadata, indent=2))

                # Add generated code files references
                files_manifest = report_data.get("generated_files", [])
                if files_manifest:
                    manifest_str = "\n".join(
                        [f['path'] for f in files_manifest]
                    )
                    zf.writestr("GENERATED_FILES.txt", manifest_str)

                # Add documentation files
                doc_files = report_data.get("documentation_files", [])
                if doc_files:
                    docs_str = "\n".join(doc_files)
                    zf.writestr("DOCUMENTATION_FILES.txt", docs_str)

                # Add README
                readme = self._create_readme(report_data)
                zf.writestr("README.md", readme)

            logger.info(f"Archive created: {archive_path}")
            return archive_path

        except Exception as e:
            logger.error(f"Failed to create archive: {str(e)}")
            raise ReportError(f"Archive creation failed: {str(e)}") from e

    def export_report(
        self,
        report_data: Dict[str, Any],
        formats: List[str] = None,
    ) -> Dict[str, Path]:
        """
        Export report in multiple formats.

        Args:
            report_data: Report data dictionary
            formats: List of formats (markdown, html, json, zip)

        Returns:
            Dictionary of format â†’ file path
        """
        if formats is None:
            formats = ["markdown", "html", "zip"]

        logger.info(f"Exporting report in formats: {formats}")

        results = {}

        for fmt in formats:
            if fmt == "zip":
                path = self.create_report_archive(report_data)
            else:
                path = self.save_report(report_data, format=fmt)

            results[fmt] = path

        return results

    def get_report_stats(self) -> Dict[str, Any]:
        """
        Get report service statistics.

        Returns:
            Statistics dictionary
        """
        report_files = list(self.reports_dir.glob("*"))
        total_size = sum(f.stat().st_size for f in report_files if f.is_file())

        return {
            "total_reports": len(report_files),
            "total_size_mb": round(total_size / 1024 / 1024, 2),
            "reports_dir": str(self.reports_dir),
            "cached_reports": len(self.report_cache),
        }

    def _markdown_to_html(self, markdown: str) -> str:
        """Simple markdown to HTML conversion."""
        html = markdown

        # Headers
        html = html.replace("# ", "<h1>").replace("\n", "</h1>\n")
        html = html.replace("## ", "<h2>").replace("\n", "</h2>\n")
        html = html.replace("### ", "<h3>").replace("\n", "</h3>\n")

        # Bold and italic
        html = html.replace("**", "<strong>").replace("__", "<em>")

        # Code blocks
        lines = []
        in_code = False
        for line in html.split("\n"):
            if line.startswith("```"):
                if not in_code:
                    lines.append("<pre><code>")
                    in_code = True
                else:
                    lines.append("</code></pre>")
                    in_code = False
            else:
                lines.append(line)

        html = "\n".join(lines)

        # Paragraphs
        html = html.replace("\n\n", "</p><p>")
        html = f"<p>{html}</p>"

        return html

    def _generate_toc(self, sections: List[Dict]) -> str:
        """Generate table of contents HTML."""
        if not sections:
            return ""

        toc = '<div class="toc"><h2>Table of Contents</h2><ul>'

        for i, section in enumerate(sections, 1):
            title = section.get("title", f"Section {i}")
            section_id = f"section-{i}"
            toc += f'<li><a href="#{section_id}">{title}</a></li>'

        toc += "</ul></div>"

        return toc

    def _create_readme(self, report_data: Dict[str, Any]) -> str:
        """Create README for archive."""
        summary = report_data.get("executive_summary", {})

        return f"""# Modernization Report

## Overview
{summary.get('overview', 'Complete modernization analysis and migration roadmap')}

## Repository
- **URL**: {report_data.get('repository_url', 'Unknown')}
- **Generated**: {report_data.get('generated_at', 'Unknown')}

## Migration Summary
- **Current Stack**: {summary.get('current_stack', 'Unknown')}
- **Target Stack**: {summary.get('target_stack', 'Unknown')}
- **Difficulty**: {summary.get('difficulty', 'Unknown')}
- **Effort**: {summary.get('effort', 'Unknown')}
- **Duration**: {summary.get('duration', 'Unknown')}

## Contents
- **REPORT.md** - Complete analysis in Markdown format
- **REPORT.html** - Interactive HTML version
- **GENERATED_FILES.txt** - List of generated code files
- **DOCUMENTATION_FILES.txt** - List of documentation files
- **metadata.json** - Report metadata

## Getting Started
1. Read REPORT.md or open REPORT.html in a browser
2. Review generated code files listed in GENERATED_FILES.txt
3. Follow the migration guide in the report
4. Refer to troubleshooting section for common issues

## Next Steps
{self._format_next_steps(summary.get('next_steps', []))}
"""

    def _format_next_steps(self, steps: List[str]) -> str:
        """Format next steps."""
        if not steps:
            return "Follow the migration roadmap in the report."

        return "\n".join([f"{i}. {step}" for i, step in enumerate(steps, 1)])


# Global report service instance
report_service = ReportService()
